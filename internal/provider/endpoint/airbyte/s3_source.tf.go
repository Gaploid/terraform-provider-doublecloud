// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cloud/doublecloud/public-api/doublecloud/transfer/v1/endpoint/airbyte/s3_source.proto

package endpoint_airbyte

import (
	fmt "fmt"
	"google.golang.org/protobuf/proto"
	math "math"

	schema "github.com/hashicorp/terraform-plugin-framework/provider/schema"
	types "github.com/hashicorp/terraform-plugin-framework/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Csv_TF struct with tfsdk field Csv S3Source.format.csv
type Csv_TF struct {
	Delimiter               types.String `tfsdk:"delimiter",json:"delimiter"`
	QuoteChar               types.String `tfsdk:"quote_char",json:"quote_char"`
	EscapeChar              types.String `tfsdk:"escape_char",json:"escape_char"`
	Encoding                types.String `tfsdk:"encoding",json:"encoding"`
	DoubleQuote             types.Bool   `tfsdk:"double_quote",json:"double_quote"`
	NewlinesInValues        types.Bool   `tfsdk:"newlines_in_values",json:"newlines_in_values"`
	BlockSize               types.Int64  `tfsdk:"block_size",json:"block_size"`
	AdditionalReaderOptions types.String `tfsdk:"additional_reader_options",json:"additional_reader_options"`
	AdvancedOptions         types.String `tfsdk:"advanced_options",json:"advanced_options"`
}

func GenTFSchemaCsv() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"additional_reader_options": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"advanced_options": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"block_size": schema.Int64Attribute{
			Description: "",
			Optional:    true,
		},
		"delimiter": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"double_quote": schema.BoolAttribute{
			Description: "",
			Optional:    true,
		},
		"encoding": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"escape_char": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"newlines_in_values": schema.BoolAttribute{
			Description: "",
			Optional:    true,
		},
		"quote_char": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
	}}
}

// Parquet_TF struct with tfsdk field Parquet S3Source.format.parquet
type Parquet_TF struct {
	BufferSize types.Int64  `tfsdk:"buffer_size",json:"buffer_size"`
	Columns    types.String `tfsdk:"columns",json:"columns"`
	BatchSize  types.Int64  `tfsdk:"batch_size",json:"batch_size"`
}

func GenTFSchemaParquet() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"batch_size": schema.Int64Attribute{
			Description: "",
			Optional:    true,
		},
		"buffer_size": schema.Int64Attribute{
			Description: "",
			Optional:    true,
		},
		"columns": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
	}}
}

// Avro_TF struct with tfsdk field Avro S3Source.format.avro
type Avro_TF struct {
	active types.Bool `tfsdk:"active",json:"active"`
}

func GenTFSchemaAvro() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{"active": schema.BoolAttribute{
		Description: "Automatically generated field preventing empty message errors",
		Optional:    true,
	}}}
}

// Jsonl_TF struct with tfsdk field Jsonl S3Source.format.jsonl
type Jsonl_TF struct {
	NewlinesInValues        types.Bool  `tfsdk:"newlines_in_values",json:"newlines_in_values"`
	UnexpectedFieldBehavior types.Int64 `tfsdk:"unexpected_field_behavior",json:"unexpected_field_behavior"`
	BlockSize               types.Int64 `tfsdk:"block_size",json:"block_size"`
}

func GenTFSchemaJsonl() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"block_size": schema.Int64Attribute{
			Description: "",
			Optional:    true,
		},
		"newlines_in_values": schema.BoolAttribute{
			Description: "",
			Optional:    true,
		},
		"unexpected_field_behavior": schema.Int64Attribute{
			Description: "",
			Optional:    true,
		},
	}}
}

// Format_TF struct with tfsdk field Format S3Source.format
type Format_TF struct {
	Csv     *Csv_TF     `tfsdk:"csv",json:"csv"`
	Parquet *Parquet_TF `tfsdk:"parquet",json:"parquet"`
	Avro    *Avro_TF    `tfsdk:"avro",json:"avro"`
	Jsonl   *Jsonl_TF   `tfsdk:"jsonl",json:"jsonl"`
}

func GenTFSchemaFormat() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"avro": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaAvro().Attributes,
			Description: "",
			Optional:    true,
		},
		"csv": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaCsv().Attributes,
			Description: "",
			Optional:    true,
		},
		"jsonl": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaJsonl().Attributes,
			Description: "",
			Optional:    true,
		},
		"parquet": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaParquet().Attributes,
			Description: "",
			Optional:    true,
		},
	}}
}

// Provider_TF struct with tfsdk field Provider S3Source.provider
type Provider_TF struct {
	Bucket             types.String `tfsdk:"bucket",json:"bucket"`
	AwsAccessKeyId     types.String `tfsdk:"aws_access_key_id",json:"aws_access_key_id"`
	AwsSecretAccessKey types.String `tfsdk:"aws_secret_access_key",json:"aws_secret_access_key"`
	PathPrefix         types.String `tfsdk:"path_prefix",json:"path_prefix"`
	Endpoint           types.String `tfsdk:"endpoint",json:"endpoint"`
	UseSsl             types.Bool   `tfsdk:"use_ssl",json:"use_ssl"`
	VerifySslCert      types.Bool   `tfsdk:"verify_ssl_cert",json:"verify_ssl_cert"`
}

func GenTFSchemaProvider() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"aws_access_key_id": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"aws_secret_access_key": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"bucket": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"endpoint": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"path_prefix": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"use_ssl": schema.BoolAttribute{
			Description: "",
			Optional:    true,
		},
		"verify_ssl_cert": schema.BoolAttribute{
			Description: "",
			Optional:    true,
		},
	}}
}

// S3Source_TF struct with tfsdk field S3Source S3Source
type S3Source_TF struct {
	Dataset     types.String `tfsdk:"dataset",json:"dataset"`
	PathPattern types.String `tfsdk:"path_pattern",json:"path_pattern"`
	Schema      types.String `tfsdk:"schema",json:"schema"`
	Format      *Format_TF   `tfsdk:"format",json:"format"`
	Provider    *Provider_TF `tfsdk:"provider",json:"provider"`
}

func GenTFSchemaS3Source() schema.SingleNestedBlock {
	return schema.SingleNestedBlock{Attributes: map[string]schema.Attribute{
		"dataset": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"format": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaFormat().Attributes,
			Description: "",
			Optional:    true,
		},
		"path_pattern": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
		"provider": schema.SingleNestedAttribute{
			Attributes:  GenTFSchemaProvider().Attributes,
			Description: "",
			Optional:    true,
		},
		"schema": schema.StringAttribute{
			Description: "",
			Optional:    true,
		},
	}}
}
